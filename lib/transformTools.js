// Generated by CoffeeScript 1.6.3
(function() {
  var configCache, endsWith, falafel, fs, getConfigFromCache, loadJsonAsync, parentDir, parentDirSync, path, skipFile, storeConfigInCache, through;

  path = require('path');

  fs = require('fs');

  through = require('through');

  falafel = require('falafel');

  parentDir = require('find-parent-dir');

  endsWith = function(str, suffix) {
    return str.indexOf(suffix, str.length - suffix.length) !== -1;
  };

  skipFile = function(file, options) {
    var answer, extension, includeThisFile, _i, _j, _len, _len1, _ref, _ref1;
    answer = false;
    if (options.excludeExtensions) {
      _ref = options.excludeExtensions;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        extension = _ref[_i];
        if (endsWith(file, extension)) {
          answer = true;
        }
      }
    }
    if (options.includeExtensions) {
      includeThisFile = false;
      _ref1 = options.includeExtensions;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        extension = _ref1[_j];
        if (endsWith(file, extension)) {
          includeThisFile = true;
          break;
        }
      }
      if (!includeThisFile) {
        answer = true;
      }
    }
    return answer;
  };

  exports.makeStringTransform = function(transformName, options, transformFn) {
    if (options == null) {
      options = {};
    }
    if (transformFn == null) {
      transformFn = options;
      options = {};
    }
    return function(file) {
      var content, end, write;
      if (skipFile(file, options)) {
        return through();
      }
      content = '';
      write = function(buf) {
        return content += buf;
      };
      end = function() {
        var handleError,
          _this = this;
        handleError = function(error) {
          if (error instanceof Error && error.message) {
            error.message += " (while processing " + file + ")";
          } else {
            error = new Error("" + error + " (while processing " + file + ")");
          }
          return _this.emit('error', error);
        };
        return exports.loadTransformConfig(transformName, file, function(err, config, configDir) {
          if (err) {
            return handleError(err);
          }
          try {
            return transformFn(content, {
              file: file,
              config: config,
              configDir: configDir
            }, function(err, transformed) {
              if (err) {
                return handleError(err);
              }
              _this.queue(String(transformed));
              return _this.queue(null);
            });
          } catch (_error) {
            err = _error;
            return handleError(err);
          }
        });
      };
      return through(write, end);
    };
  };

  exports.makeFalafelTransform = function(transformName, options, transformFn) {
    var falafelOptions, _ref;
    if (options == null) {
      options = {};
    }
    if (transformFn == null) {
      transformFn = options;
      options = {};
    }
    falafelOptions = (_ref = options.falafelOptions) != null ? _ref : {};
    return exports.makeStringTransform(transformName, options, function(content, transformOptions, done) {
      var pending, transformCb, transformErr, transformed;
      transformErr = null;
      pending = 1;
      transformed = null;
      transformCb = function(err) {
        if (err && !transformErr) {
          transformErr = err;
          done(err);
        }
        if (transformErr) {
          return;
        }
        pending--;
        if (pending === 0) {
          return done(null, transformed);
        }
      };
      transformed = falafel(content, falafelOptions, function(node) {
        var err;
        pending++;
        try {
          return transformFn(node, transformOptions, transformCb);
        } catch (_error) {
          err = _error;
          return transformCb(err);
        }
      });
      return transformCb(transformErr, transformed);
    });
  };

  exports.makeRequireTransform = function(transformName, options, transformFn) {
    var evaluateArguments, _ref;
    if (options == null) {
      options = {};
    }
    if (transformFn == null) {
      transformFn = options;
      options = {};
    }
    evaluateArguments = (_ref = options.evaluateArguments) != null ? _ref : true;
    return exports.makeFalafelTransform(transformName, options, function(node, transformOptions, done) {
      var arg, args, dirname, varNames, vars;
      if (node.type === 'CallExpression' && node.callee.type === 'Identifier' && node.callee.name === 'require') {
        if (evaluateArguments) {
          dirname = path.dirname(transformOptions.file);
          varNames = ['__filename', '__dirname', 'path', 'join'];
          vars = [transformOptions.file, dirname, path, path.join];
          args = node["arguments"].map(function(arg) {
            var err, t;
            t = "return " + (arg.source());
            try {
              return Function(varNames, t).apply(null, vars);
            } catch (_error) {
              err = _error;
              return arg.source();
            }
          });
        } else {
          args = (function() {
            var _i, _len, _ref1, _results;
            _ref1 = node["arguments"];
            _results = [];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              arg = _ref1[_i];
              _results.push(arg.source());
            }
            return _results;
          })();
        }
        return transformFn(args, transformOptions, function(err, transformed) {
          if (err) {
            return done(err);
          }
          if (transformed != null) {
            node.update(transformed);
          }
          return done();
        });
      } else {
        return done();
      }
    });
  };

  configCache = {};

  getConfigFromCache = function(transformName, packageDir) {
    var cacheKey;
    cacheKey = "" + transformName + ":" + packageDir;
    if (configCache[cacheKey] != null) {
      return configCache[cacheKey];
    } else {
      return null;
    }
  };

  storeConfigInCache = function(transformName, packageDir, config, configDir) {
    var cacheKey;
    cacheKey = "" + transformName + ":" + packageDir;
    return configCache[cacheKey] = {
      config: config,
      configDir: configDir
    };
  };

  loadJsonAsync = function(filename, done) {
    return fs.readFile(filename, "utf-8", function(err, content) {
      if (err) {
        return done(err);
      }
      try {
        return done(null, JSON.parse(content));
      } catch (_error) {
        err = _error;
        return done(err);
      }
    });
  };

  exports.loadTransformConfig = function(transformName, file, done) {
    var dirname;
    dirname = path.dirname(file);
    return parentDir(dirname, 'package.json', function(err, packageDir) {
      var cachedConfig, packageFile;
      if (err) {
        return done(err);
      }
      cachedConfig = getConfigFromCache(transformName, packageDir);
      if (cachedConfig) {
        return done(null, cachedConfig.config, cachedConfig.configDir);
      } else if (packageDir != null) {
        packageFile = path.join(packageDir, 'package.json');
        return loadJsonAsync(packageFile, function(err, pkg) {
          var config, configDir, configFile;
          if (err) {
            return done(err);
          }
          config = pkg[transformName];
          configDir = packageDir;
          if ((config != null) && (typeof config === "string")) {
            configFile = path.resolve(packageDir, config);
            configDir = path.dirname(configFile);
            try {
              config = require(configFile);
            } catch (_error) {
              err = _error;
              return done(err);
            }
          }
          storeConfigInCache(transformName, packageDir, config, configDir);
          return done(null, config, configDir);
        });
      } else {
        return done(null, null);
      }
    });
  };

  parentDirSync = function(startDir, fileToFind) {
    var answer, dirToCheck, existsSync, oldDirToCheck, _ref;
    existsSync = (_ref = fs.existsSync) != null ? _ref : path.existsSync;
    dirToCheck = path.resolve(startDir);
    answer = null;
    while (true) {
      if (existsSync(path.join(dirToCheck, fileToFind))) {
        answer = dirToCheck;
        break;
      }
      oldDirToCheck = dirToCheck;
      dirToCheck = path.dirname(dirToCheck);
      if (oldDirToCheck === dirToCheck) {
        break;
      }
    }
    return answer;
  };

  exports.loadTransformConfigSync = function(transformName, file) {
    var answer, config, configDir, configFile, dirname, packageDir, packageFile, pkg;
    config = null;
    dirname = path.dirname(file);
    packageDir = parentDirSync(dirname, 'package.json');
    answer = getConfigFromCache(transformName, packageDir);
    if (!answer && (packageDir != null)) {
      configDir = packageDir;
      packageFile = path.join(packageDir, 'package.json');
      pkg = require(packageFile);
      config = pkg[transformName];
      if ((config != null) && (typeof config === "string")) {
        configFile = path.resolve(packageDir, config);
        configDir = path.dirname(configFile);
        config = require(configFile);
      }
      storeConfigInCache(transformName, packageDir, config, configDir);
      answer = {
        config: config,
        configDir: configDir
      };
    }
    return answer;
  };

  exports.clearConfigCache = function() {
    return configCache = {};
  };

  exports.runTransform = function(transform, file, options, done) {
    var doTransform;
    if (options == null) {
      options = {};
    }
    if (done == null) {
      done = options;
      options = {};
    }
    doTransform = function(content) {
      var data, err, throughStream;
      data = "";
      err = null;
      throughStream = transform(file);
      throughStream.on("data", function(d) {
        return data += d;
      });
      throughStream.on("end", function() {
        if (!err) {
          return done(null, data);
        }
      });
      throughStream.on("error", function(e) {
        err = e;
        return done(err);
      });
      throughStream.write(content);
      return throughStream.end();
    };
    if (options.content) {
      return process.nextTick(function() {
        return doTransform(options.content);
      });
    } else {
      return fs.readFile(file, "utf-8", function(err, content) {
        if (err) {
          return done(err);
        }
        return doTransform(content);
      });
    }
  };

}).call(this);
